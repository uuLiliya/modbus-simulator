# 命令历史导航功能

## 概述

本项目的TCP客户端和服务端现已支持命令历史导航功能，类似于bash shell的历史记录功能。用户可以使用上下箭头键浏览之前输入的命令，并可以编辑后重新发送。

## 功能特性

### 1. 命令历史存储

- **循环缓冲区**: 使用循环队列方式存储历史命令，避免内存浪费
- **容量**: 最多存储100条历史命令 (MAX_HISTORY_SIZE)
- **自动去重**: 连续相同的命令不会重复添加到历史记录
- **空命令过滤**: 空命令或只包含空白字符的命令不会被记录

### 2. 键盘输入捕获

支持以下按键：

| 按键 | 功能 | 转义序列 |
|------|------|----------|
| 上箭头 (↑) | 浏览上一条历史命令 | `\033[A` |
| 下箭头 (↓) | 浏览下一条历史命令 | `\033[B` |
| 左箭头 (←) | 光标向左移动 | `\033[D` |
| 右箭头 (→) | 光标向右移动 | `\033[C` |
| Backspace | 删除光标前的字符 | ASCII 127 |
| Enter | 发送命令 | `\n` |
| Ctrl+C | 取消当前输入 | ASCII 3 |
| Ctrl+D | 退出（空行时） | ASCII 4 |

### 3. 历史导航

- **向后浏览**: 按上箭头键，从最新的命令开始向历史方向浏览
- **向前浏览**: 按下箭头键，从历史向最新方向浏览
- **边界处理**: 到达最早或最新命令时停止导航
- **临时保存**: 开始导航时，当前正在输入的内容会被临时保存
- **恢复输入**: 按下箭头回到最新状态时，恢复之前保存的输入

### 4. 用户交互优化

- **实时刷新**: 历史命令显示时清除当前行并重新显示
- **光标控制**: 支持左右箭头键移动光标位置
- **编辑功能**: 可以对历史命令进行编辑后再发送
- **提示符**: 清晰的提示符显示 `[你] ` (客户端) 或 `[服务器] ` (服务器)

## 实现架构

### 核心数据结构

```c
/* 命令历史记录管理结构体 */
typedef struct {
    char commands[MAX_HISTORY_SIZE][MAX_COMMAND_LENGTH];  /* 历史命令循环缓冲区 */
    int count;                      /* 当前已存储的历史命令总数 */
    int head;                       /* 循环缓冲区头部位置（最新命令） */
    int current;                    /* 当前浏览位置（用于上下导航） */
    bool navigating;                /* 是否正在浏览历史记录 */
} CommandHistory;
```

### 主要函数

#### 历史管理函数
- `init_history()` - 初始化历史记录结构
- `add_to_history()` - 添加命令到历史记录
- `get_previous_command()` - 获取上一条命令
- `get_next_command()` - 获取下一条命令
- `reset_history_navigation()` - 重置导航状态

#### 终端控制函数
- `enable_raw_mode()` - 启用终端raw模式（禁用行缓冲和回显）
- `disable_raw_mode()` - 恢复终端原始设置

#### 交互式输入函数
- **客户端**: `read_line_with_history()` - 阻塞式输入，同时监听socket
- **服务器**: `process_server_input_char()` - 非阻塞式字符处理，适配epoll

### 客户端实现

客户端使用 `read_line_with_history()` 函数，该函数：
1. 设置终端为raw mode
2. 使用select()同时监听stdin和socket
3. 逐字符读取和处理用户输入
4. 检测箭头键的转义序列
5. 更新显示和历史导航
6. 当socket有数据时返回特殊值，让主循环处理服务器消息

### 服务器实现

服务器使用 `process_server_input_char()` 函数，该函数：
1. 在epoll检测到stdin可读时被调用
2. 非阻塞地读取一个字符
3. 使用状态机处理转义序列
4. 当完成一行输入时返回命令
5. 不阻塞epoll主循环，保证服务器能继续处理客户端请求

## 使用方法

### 启动服务器

```bash
./server 8888
```

服务器启动后，你会看到：
```
[服务器] 正在监听端口 8888（最大客户端数: 128）
[服务器] 输入 'help' 查看可用命令（支持上下箭头键导航命令历史）
```

### 启动客户端

```bash
./client 127.0.0.1 8888
```

客户端连接后，你会看到：
```
[客户端] 连接成功！
[客户端] 可用命令：
  modbus read <起始地址> <数量>   - 读取保持寄存器 (FC03)
  modbus write <地址> <值>        - 写单个寄存器 (FC06)
  quit                             - 退出程序
  或输入任意文本消息发送给服务器
  使用上下箭头键导航命令历史
```

### 测试历史导航

1. **输入一些命令**:
```
[你] hello
[你] world
[你] test message
[你] modbus read 0 5
```

2. **按上箭头键**:
   - 第一次: 显示 `modbus read 0 5`
   - 第二次: 显示 `test message`
   - 第三次: 显示 `world`
   - 第四次: 显示 `hello`

3. **按下箭头键**:
   - 向前浏览到更新的命令
   - 最终回到空输入状态

4. **编辑历史命令**:
   - 按上箭头选择一个历史命令
   - 使用左右箭头移动光标
   - 使用退格键删除字符
   - 输入新字符
   - 按回车发送修改后的命令

## 代码文件

### 新增文件
- `history.c` - 历史记录管理和交互式输入实现

### 修改文件
- `common.h` - 添加历史相关的结构体和函数声明
- `client.c` - 集成历史导航功能
- `server.c` - 集成历史导航功能
- `Makefile` - 添加history.c的编译

## 技术细节

### 终端Raw Mode

启用raw mode时的设置：
```c
struct termios raw = original;
raw.c_lflag &= ~(ICANON | ECHO);  /* 禁用行缓冲和回显 */
raw.c_cc[VMIN] = 0;                /* 非阻塞读取 */
raw.c_cc[VTIME] = 0;               /* 无超时 */
```

### 转义序列检测

箭头键生成的转义序列：
- ESC (27) + '[' (91) + 'A' (65) = 上箭头
- ESC (27) + '[' (91) + 'B' (66) = 下箭头
- ESC (27) + '[' (91) + 'C' (67) = 右箭头
- ESC (27) + '[' (91) + 'D' (68) = 左箭头

### ANSI转义码

用于控制光标和显示：
- `\r` - 移动光标到行首
- `\033[K` - 清除从光标到行尾
- `\033[C` - 光标右移一个字符
- `\033[D` - 光标左移一个字符
- `\033[nD` - 光标左移n个字符

### 循环缓冲区

历史记录使用循环队列存储：
```
head指向最新命令的位置
当未填满时: 索引范围 [0, count-1]
当已填满时: 索引范围 [0, MAX_HISTORY_SIZE-1]
最旧命令位置: (head + 1) % MAX_HISTORY_SIZE
```

## 验证测试

运行验证脚本：
```bash
./verify_compilation.sh
```

该脚本会检查：
- 所有历史相关函数是否正确编译和链接
- 源代码中是否包含关键特性
- 实现细节是否完整

## 注意事项

1. **终端兼容性**: 需要支持ANSI转义序列的终端（大多数现代终端都支持）
2. **后台运行**: 服务器在后台运行时，stdin处理会受到限制
3. **线程安全**: 当前实现是单线程的，多线程环境需要额外的同步
4. **缓冲区大小**: 单条命令最长1024字符 (MAX_COMMAND_LENGTH)

## 编译要求

- GCC编译器
- C99标准
- Linux系统（使用了termios、select等系统调用）

## 许可证

与主项目相同
